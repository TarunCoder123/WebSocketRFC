
   The protocol has two parts: a handshake and the data transfer.

   The handshake from the client looks as follows:

        GET /chat HTTP/1.1
        Host: server.example.com
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
        Origin: http://example.com
        Sec-WebSocket-Protocol: chat, superchat
        Sec-WebSocket-Version: 13

   The handshake from the server looks as follows:

        HTTP/1.1 101 Switching Protocols
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
        Sec-WebSocket-Protocol: chat

   The leading line from the client follows the Request-Line format.
   The leading line from the server follows the Status-Line format.  The
   Request-Line and Status-Line productions.

   An unordered set of header fields comes after the leading line in
   both cases.  The meaning of these header fields is specified in
   Section 4 of this document.  Additional header fields may also be
   present, such as cookies.  The format and parsing of
   headers.

   Once the client and server have both sent their handshakes, and if
   the handshake was successful, then the data transfer part starts.
   This is a two-way communication channel where each side can,
   independently from the other, send data at will.

   After a successful handshake, clients and servers transfer data back
   and forth in conceptual units referred to in this specification as
   "messages".  On the wire, a message is composed of one or more

   frames.  The WebSocket message does not necessarily correspond to a
   particular network layer framing, as a fragmented message may be
   coalesced or split by an intermediary.

   A frame has an associated type.  Each frame belonging to the same
   message contains the same type of data.  Broadly speaking, there are
   types for textual data (which is interpreted as UTF-8 [RFC3629]
   text), binary data (whose interpretation is left up to the
   application), and control frames (which are not intended to carry
   data for the application but instead for protocol-level signaling,
   such as to signal that the connection should be closed).  This
   version of the protocol defines six frame types and leaves ten
   reserved for future use.
